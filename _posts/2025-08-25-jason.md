---
layout:     post
title:      "Three Months Later: How PRISM Died and JASON Was Born(e)"
subtitle:   "when your project meets the unforgiving reality of actually trying to build it"
date:       2025-08-25 02:22:00
author:     "Mac"
header-img: "img/in-post/prism.jpg"
catalog: true
tags:
    - Networking
    - Firewall
    - Selfhosting
---

> "Talk about a hiatus"

It's been three months since my last blog post. Three months since I wrote about discovering that security nightmare during my intern, three months since I had that late-night idea about polymorphic defense mechanisms, three months since I confidently declared that PRISM would revolutionize IoT security.

Three months of pure, unrelenting technical hell.

I haven't written anything because I've been too busy banging my head against wall after wall after wall. PRISM : my ever so beautiful, elegant, theoretically perfect polymorphic IoT security gateway—turned out to be one of those ideas that sounds brilliant at 2 AM but becomes a nightmare when you actually try to build it.

This is an explanation of how PRISM died, and how something much better emerged from the ashes: JASON

## **The Honeymoon Phase**

Remember that moment I described? Sitting in a caffeine-induced haze, suddenly realizing that polymorphic techniques could flip cybersecurity on its head? That moment felt like discovering fire. I was convinced I'd found the silver bullet for IoT security.

Even the concept was elegant: create security gateways that looked completely different to attackers while maintaining identical defensive capabilities. Make mass exploitation impossible by ensuring that no two targets ever looked the same. Change the fundamental economics of cybercrime by making scalable attacks unscalable.

I spent the first few weeks sketching architectures, researching polymorphic algorithms, and building proof-of-concept code. Everything seemed to click into place. The Raspberry Pi Zero 2W had just enough processing power. The networking stack in Linux was flexible enough. The cryptographic libraries were mature enough.

I was going to "save" the world from insecure IoT devices, one polymorphic gateway at a time.

## **Reality Hits Like Shatabdi**

The first wall I hit was computational complexity. Polymorphism, by definition, have to constantly regenerate themselves. That means cpu cycles. Lots of cpu cycles.

My beautiful algorithms that looked so elegant on paper consumed processing power like a cryptocurrency mining operation. The Raspberry Pi Zero 2W, which was already not exactly a powerhouse; would just grind to a halt trying to maintain transformations while simultaneously handling network traffic for multiple IoT devices.

Okay, I thought, maybe I need more powerful hardware.

So I upgraded to Raspberry Pi 4s. The computational load was more manageable, but now I had new problems. The more complex the transformations became, the more likely they were to break legitimate device functionality. IoT devices are notoriously finicky about network conditions, and my shape-shifting gateways kept triggering edge cases in device firmware.

Smart thermostats would lose connectivity randomly. Security cameras would fail to authenticate with their cloud services. Printers would mysteriously stop accepting print jobs. Every variation seemed to introduce new incompatibilities with real-world devices.
The Debugging Nightmare

Debugging a system like this is equivalent to trying to fix a car that changes its engine configuration every few minutes. Just when you think you've identified the problem, the system morphs into a different configuration and the issue disappears—or gets replaced by three new ones.

I spent weeks chasing phantom network issues that would appear in one iteration and vanish in the next. Traffic that flowed perfectly through configuration A would mysteriously fail in configuration B, but only for certain types of devices, and only under specific network conditions, and only on Tuesdays when Mercury was in retrograde.

The logs were useless because every config generated different log formats and error messages. The debugging tools couldn't keep up with the constantly shifting topology. I felt like I was trying to debug a system that was actively conspiring against me.

## **The Management Complexity Horror Show**

Even when I got the basic mechanisms working, I realized I'd created a management nightmare. How do you configure a system that's designed to be different every time? How do you troubleshoot network issues when the network is constantly changing? How do you maintain security policies across variations that are specifically designed to look different?

I built web interfaces that became obsolete as soon as the system morphed. I wrote documentation that was accurate for exactly one iteration before becoming misleading. I created monitoring systems that couldn't track metrics across changes.

The system was becoming more complex to manage than the IoT security problems it was supposed to solve.
The Burnout

By month two, I was working 16-hour days and dreaming about network configurations. My roomlooked like a electronics graveyard—Raspberry Pis, network switches, breadboards, and cables everywhere. I had notes covered in increasingly desperate diagrams trying to solve the unsolvable puzzle.

The worst part in all this, was the growing realization that I might have been chasing a fundamentally flawed concept. Maybe polymorphic defense was too clever for its own good. Maybe the complexity wasn't a engineering challenge to be solved, but a fundamental flaw in the approach.

## **The Breaking Point**

The breaking point came during a particularly brutal debugging session in late August. I'd been trying to figure out why a smart doorbell would work perfectly in A but completely fail to connect in B. After 11 hours of packet captures, code reviews, and increasingly desperate experimentation, I realized the problem was in a timing dependency buried deep in the doorbell's firmware that only manifested when certain network characteristics aligned in precisely the wrong way.

I could fix this specific issue, but there were probably hundreds of similar edge cases lurking in the combinations of configurations and real-world devices. I was playing an unwinnable game of whack-a-mole against the combined quirks of thousands of different implementations.

That's when I did something I should have done months earlier: I asked myself the same question that had originally inspired PRISM.

"What do I actually need this system to do?"

## **The Epiphany: Good Enough Is Good Enough**

Sitting in my electronics-strewn room at 3 AM, surrounded by the wreckage of three months of overengineering, I had a moment of clarity.

I didn't need polymorphic shape-shifting network gateways. I didn't need to revolutionize cybersecurity architecture. I didn't need to change the fundamental economics of cybercrime.

I needed to protect my devices from the hostile networks I encounter every day. I needed to isolate untrustworthy devices from my personal equipment. I needed to filter malicious traffic before it could reach anything I cared about. And I needed all of this to work reliably without requiring a PhD in computer science to maintain.

PRISM was trying to be too clever. What I actually needed was a system that was smart enough to be effective but simple enough to be reliable.

That's when JASON was born.

## **JASON: Simplicity That Actually Works**

JASON i.e. Just Another Secure On-prem Network, represents everything PRISM should have been. Instead of polymorphic complexity, it uses layered simplicity. Instead of revolutionary new concepts, it implements proven security principles in straightforward, maintainable ways.

The architecture is almost embarrassingly simple: three single-board computers, each with a specific job, working together to create comprehensive security coverage.

### Layer One: The NanoPi R1S - Hardened Access Point

The first lesson I learned from PRISM's failure was that wireless security doesn't need to be polymorphic—it just needs to be properly configured. The R1S runs OpenWrt with enterprise-grade wireless hardening that most home users never see:

WPA2-Enterprise with RADIUS authentication means every device gets unique credentials instead of sharing a common WiFi password. If one device gets compromised, the attacker can't use those credentials to connect additional equipment.

Private Pre-Shared Key (PPSK) gives each device its own authentication key while maintaining the simplicity of PSK authentication. Your laptop, phone, and smart watch all have different wireless credentials, but they all connect transparently.

802.11w Management Frame Protection prevents attackers from disconnecting your devices by spoofing wireless management frames. It's a simple but effective defense against a common attack vector.

Client isolation ensures that devices can't directly communicate through the wireless network, even if they're connected to the same access point. Each device exists in its own isolated wireless bubble.

The beautiful part is that all this hardening is completely transparent to your devices. They connect normally and work normally, but the underlying security is non-invasive.

### Layer Two: The NanoPi R2S - IPFire Fortress

The R2S runs IPFire, a beautifully specialised firewall distribution that implements network segmentation through VLANs. This creates separate, isolated network neighborhoods within the same physical infrastructure.

IoT devices get their own segregated network segment with ruthlessly simple rules:

    IoT devices can reach the internet (for cloud services and updates)

    IoT devices cannot reach the main network (where your personal devices live)

    Main network devices can reach IoT devices (for management purposes)

IPFire also runs Suricata, an intrusion detection and prevention system that analyzes traffic patterns in real-time. It knows what normal IoT traffic looks like and can spot suspicious behavior—devices scanning internal networks, connecting to known malicious domains, or exhibiting botnet characteristics.

### Layer Three: The Raspberry Pi 3B+ - Intelligence Hub

The Pi runs containerized security services using Docker, making the entire system modular and maintainable. Each service runs in its own isolated container, so updates and troubleshooting don't affect other components.

CrowdSec provides collaborative security through shared threat intelligence. When attackers scan my network, CrowdSec analyzes the attack patterns and shares them with a global community of over 65,000 other installations. In return, JASON gets real-time protection against attacks happening worldwide.

Pi-hole (ol' reliable) provides DNS-level filtering, blocking ads, trackers, and malicious domains before they can reach any device on the network. It's remarkable how much cleaner and faster the internet becomes when you're not constantly downloading advertisements.

Suricata and Snort provide redundant intrusion detection with different detection engines and signature databases. In security, redundancy isn't inefficiency—it's comprehensive coverage.

## **The Magic: How Simplicity Wins**

Here's what happens when you connect a device to JASON:

    - Unique Authentication: Each device has its own wireless credentials

    - Automatic Classification: JASON determines device type and assigns appropriate network access

    - Network Isolation: Devices get internet access but are isolated from other devices and sensitive network segments

    - Real-time Monitoring: All traffic is analyzed by multiple security systems simultaneously

    - Proactive Filtering: Malicious domains and attack sources are blocked automatically

    - Collaborative Intelligence: Attack patterns are shared globally and new threats are blocked proactively

The entire process is transparent to your devices but provides enterprise-grade security monitoring and protection.

## **Real-World Success: JASON in the Wild**

I've been traveling with JASON for months now, and it's been revelation. The entire system fits in a nice printed case (new rabbit hole unlocked) smaller than a laptop bag. Setup takes under five minutes. And it just works.

In hotels, JASON connects to the provided WiFi and creates a secure, monitored network for all my devices. In remote locations, I tether it to my phone's hotspot and get the same protection. The 128GB SSD in the Pi doesn't just store security logs—it's loaded with movies and TV shows, turning JASON into a portable entertainment system that also happens to be a fortress-grade security appliance.

The statistics are eye-opening:

    Pi-hole blocks 31% of all DNS requests (thousands of tracking and malicious domains)

    CrowdSec blocks dozens of scanning attempts daily

    Intrusion detection systems regularly catch suspicious IoT behavior

    Network segmentation prevents lateral movement during the rare times devices are compromised

## **The Economics**

The complete hardware costs less than ₹10,000:

    NanoPi R1S: ₹1,200

    NanoPi R2S: ₹2,500

    Raspberry Pi 3B+: ₹3,500

    Accessories and storage: ₹1,000

Compare that to enterprise security appliances starting at ₹50,000 with annual licensing fees, and you understand why I'm excited about this approach. JASON provides security capabilities that rival commercial solutions while being completely open-source and vendor-independent.

## **Why PRISM Had to Die**

PRISM failed because I fell in love with theoretical elegance instead of practical effectiveness. Polymorphic defense mechanisms are intellectually beautiful, but they create operational complexity that defeats their security benefits.

JASON succeeds because it embraces proven security principles implemented in maintainable architectures. Network segmentation works. Intrusion detection works. Collaborative threat intelligence works. The magic isn't in revolutionary new concepts—it's in combining established techniques in thoughtful ways.

The three-layer architecture provides separation of concerns: wireless security, network filtering, and intelligence analysis each happen in dedicated systems optimized for their specific roles. When problems occur, they're isolated to single layers instead of cascading through monolithic complexity.

The containerized intelligence layer means I can experiment with new security tools without risking core functionality. Want to try a new intrusion detection system? Spin up a container. Need to update threat intelligence feeds? Update that service without touching network infrastructure.
The Future: Evolution Without Revolution

JASON's modular architecture means it can evolve as threats change and better hardware becomes available. I'm already experimenting with more powerful ARM boards and considering edge AI capabilities for local threat analysis.

But the core philosophy remains the same: practical security that actually works. JASON doesn't try to revolutionize cybersecurity—it just implements good security principles in ways that real people can deploy, maintain, and rely on.
Why This Matters

Those three months of failure weren't wasted time, they were essential education. I learned that the most sophisticated solution isn't always the best solution. I learned that engineering elegance means nothing if the system is too complex to maintain. Most importantly, I learned to ask the right question: not "what's theoretically possible?" but "what actually needs to work?"

JASON proves that effective security doesn't require enterprise budgets or vendor solutions. It demonstrates that open-source tools, commodity hardware, and thoughtful architecture can create security systems that work in the real world.

The collaborative security model shows how individual defenders can work together to stay ahead of threats through shared intelligence. Every JASON deployment makes the global network smarter and more secure.

## **Starting Over: The Best Decision I Never Planned to Make**

Looking back, those three months of struggling with PRISM were exactly what I needed. The frustration, the burnout, the growing realization that I was solving the wrong problem; all of that was necessary to get here.

PRISM tried to change the world through revolutionary complexity. JASON changes my daily digital life through evolutionary simplicity.

Sometimes the best solutions come not from brilliant innovations, but from accepting that good enough is actually pretty great when it works reliably every single day.

PRISM is dead. Long live JASON.

The complete build documentation and configuration files will be updated in a github repo once I iron out all the issues. Sometimes the most important engineering lesson is knowing when to start over.
---